// 記事テンプレート
extends ../template

// 記事のタイトルをココに
block title
	title Javascript: nullとundefined, NaN

// 記事本文
block contents
	h1 nullとundefined, NaN
	section
		div.
			Javascriptの値である、nullとundefinedとNaNについて解説します。
			「無効な値」としてよく出てきますが、それぞれ違うものなので混同しないように。

	section
		h1 nullとundefined
		div.
			まずはnullとundefinedの例。
			比較的似た者同士。

		script(title="unllとundefined", type="code/Javascript").
			// 変数の定義
			var a;
			var b = null;
			console.log(a); // 宣言しただけではなにも代入していないのでundefined
			console.log(b); // 明示的にnullを代入しているのでnull

			// 新しいオブジェクトを作成
			var obj = {
				A:"string A!",
			};
			console.log(obj.A); // -> "string A!"
			console.log(obj.B); // まだプロパティを定義していないのでundefined

		div.
			undefinedは「未定義」の意味であり、varで変数を宣言したが代入されていないもの、またはオブジェクトの存在しないプロパティがundefinedとして判定されます。
		p.
			対してnullは明示的に代入されたものなので、誰かが意図してnullに設定したものです。
			デバッグ時にundefinedが出てきたら、スペルミスの場合も多々あります。

	section
		h1 NaN (not a number)
		div.
			NaNとは、「not a number」の略です。その名のとおり、変数が「数字ではない」状態。正確には「数字になりたかったのになれなかった数字」です。
			計算式で、暗黙の型変換で数字として扱えなかった場合にNaNが返されます。

		script(title="NaN", type="code/Javascript").
			var a = 1; // Number:1
			var b = "ABC"; // String:ABC

			console.log(a / 2); // Number:0.5
			console.log(a / b); // 1 ÷ "ABC"が計算できずにNaNになる

	section
		h1 NaNの判定方法
		div.
			NaNの判定はちょっと特殊です。<code>===</code>による判定ができません！

		script(title="NaNの比較", type="code/Javascript").
			// NaN同士はイコールではない！
			console.log(NaN == NaN); // false;
			console.log(NaN === NaN); // false;

			// NaN同士は違うオブジェクト?!
			console.log(NaN != NaN); // true;
			console.log(NaN !== NaN); // true;

		div なんと、NaN同士はイコールになりません。
		div そのかわり、<code>!==</code>でtrueと判定されます。なんてステキなあまのじゃく。

		p イコール演算子の存在意義を否定するような動作ですが、同一オブジェクトにも関わらず"イコールではない"と判定されるのはNaNだけです。
		p.
			もうひとつ、NaNの判定には<code>Number.isNaN</code>関数が使えます。
			Javascriptには<code>isNaN</code>という紛らわしいグローバル関数(!)がありますが、こちらはNaNのみではなく数字に変換できないものは全てtrueを返します。NaNのみを判定したい場合に使えません。

		script(title="NaNの判定", type="code/Javascript").
			//NumberにはNaNを判定する関数がある
			Number.isNaN(NaN); // true
			Number.isNaN("日本語"); // 数字にできないがNaNではないのでfalse

			// グローバル関数のisNaNは数字に変換できない場合にtrueを返す
			isNaN(NaN); // NaNでtrueが返るが・・・
			isNaN('ABC'); // ただの文字列も数字に変換できないのでtrueを返す
			isNaN(true); // false。暗黙の変換で1になるので数値扱い

	section
		h1 どちらを採用すべきか？
		div さて、NaNの判定には<code>Number.isNaN()</code>と<code>!==</code>の２種類が使えることがわかりました。どちらを使うべきでしょうか？

		p <code>Number.isNaN()</code>はタイプ数が多いので面倒ですが、Javascriptを知らなくてもなんとなく意味はわかります。
		p <code>!==</code>の方が、圧倒的にタイピング量が少なくエコです。しかしNaNを理解していないメンバーを混乱させてしまうかもしれません。

	section
		h1 NaN判定方式のパフォーマンス測定
		div そもそも、<code>!==</code>と<code>Number.isNaN()</code>のどっちが速く処理できるでしょう？
		div そんなわけで、簡易計測してみました。

		script(title="NaNの判定", type="code/Javascript").
			+function(){
				var i, r, times = 1000 * 1000;//100万回

				// !==によるパフォーマンス測定
				console.time('!==');
				for(i = times; i--;) r = (NaN !== NaN);
				console.timeEnd('!=='); // !==: 442.885ms

				// Number.isNaNによるパフォーマンス測定
				console.time('isNaN');
				for(i = times; i--;) r = Number.isNaN(NaN);
				console.timeEnd('isNaN');// isNaN: 446.753ms
			}();

		div 手元のchromeでの計測は、100万回の繰り返しで最大30msくらいの差がありました。若干、<code>!==</code>の方が速いです。
		div でも100万回でたったこれだけの差なので、処理パフォーマンスについては考慮しなくても良さそうです。

		p.
			結論としては、どっちでもいいかなーと思います。
			NaNそのものを判定するケースは少なく、「数字であるか？」の様なパラメータチェック的な用途が多いと思います。
			それをプロジェクトのフレームワークとして提供するのがいいでしょう。
			共通化しておけば、もし判定ロジックにバグがあっても修正は一箇所で済みます。

		p
			+infolink('Javascript: 数値判定(isNumeric)関数の作成', 'framework/function-isNumeric')

	section
		h1 まとめ
		div
			| NaNで予想外に盛り上がってしまいましたが、この節を簡単にまとめると
			ul
				li undefinedは変数がまだ初期化されていない、またはプロパティがない
				li nullは代入済み
				li NaNは数字になれなかったヤツ
				li NaNを判定するには<code>Number.isNaN()</code>か<code>value !== value</code>を使う
			| となります。
		p.
			<code>value !== value</code>なので間違えないように。<br>
			<code>value !== NaN</code>だと全てがfalseになるので使えないよ。

// ライター情報
block writer
	include ../persons/TomoYoshida