// 記事テンプレート
extends ../../template.jade

// 記事のタイトルをココに
block title
	title apply, call

// 記事本文
block contents
	h1 apply, call

	section
		div.

	section
		h1 apply, call呼び出しパターン
		div Javascriptの良いところであり悪いところでもあるのが、thisを自由に指定することができることです。

		div.
			関数はそれ自身に<code>apply</code>と<code>call</code>というメソッドを持っています。
			このメソッドを使うと、実行時のthisにあたるオブジェクトを引数に渡すことができます。
			この実行時の"this"にあたるオブジェクトを「実行コンテキスト」と呼びます。
			実行コンテキストがnull,またはundefinedの場合はglobalオブジェクトを実行コンテキストとして実行します。

	section
		h1 ロード済み関数
		div.
			動作確認用に、下記の関数がこのページでロード済みです。

		script(title="thisを調べる関数",type="code/Javascript").
			function showThis(arg1, arg2) {
				// thisが何者なのかを表示
				var msg = "this is '" + (this === window ? 'Window' : this.name);
				// 引数を表示する
				msg += "': " + arg1 + ", " + arg2;
				console.log(msg);
			}

			// 実行時コンテキストダミー
			var dummy = {
				name: 'DUMMY',
			};
		div.
			実行時コンテキストである"this"をチェックし、グローバルオブジェクトかそれ以外かを表示します。

		div.
			showThis関数を関数として呼び出すと、前章で解説したとおりグローバルオブジェクトになります。
		script(title="thisを調べる関数",type="code/Javascript").
			showThis("引数1", "引数2");
			// -> this is 'Window': 引数1, 引数2

	section
		h1 apply
		div.
			applyは、関数に実行コンテキストを与え、引数をまとめて渡すことができます。
			引数そのままで関数をラップする場合などに使います。

		script(title="applyの例",type="code/Javascript").
			// 引数は配列にまとめて渡す
			showThis.apply(dummy, ["引数1", "引数2"]);

			// 実行コンテキストをdummyにして実行するラッパー関数
			function wrapper(arg1, arg2) {
				showThis.apply(dummy, arguments);
			}

			// ラップ関数を使い、引数をそのままつかう
			wrapper("引数A", "引数B");

			// コンテキストを渡さずに実行
			showThis.apply(null, ["引数α", "引数β"]);

		div.
			ラッパー関数<code>wrapper</code>に渡された引数を、そのまま<code>showThis</code>関数に渡しています。
		div.
			applyに実行コンテキストとしてdummyを渡しています。このdummyがnull, またはundefinedの場合、実行コンテキストはグローバルオブジェクトになります。

	// ここから要改定1/5
	section
		h1 call
		ul
			li 通常の関数のように、引数を列挙する
			li 呼び出し方法は function.apply(thisObj, arg1, arg2, arg3...)



		script(title="call, apply",type="code/Javascript").

			var _this = {value:"this is another object!"};

			var obj = {
				value : "this is obj!!",
				method : function(a,b){
					console.log("%s, %s, %s", this.value, a, b);
				}
			}
			// objのメソッド呼び出しなのでコンテキストはobj
			obj.method("A", "B");
			// 実行結果：this is obj!!, A, B

			// apply, callに実行コンテキストを渡すと、thisを変更できる！
			obj.method.apply(_this, ["apply", "B"]);
			obj.method.call(_this, "call", "B");
			// 実行結果：this is another object!, apply, B
			// 実行結果：this is another object!, call, B

			// コンテキストを指定しない場合、グローバルオブジェクトになる
			window["value"] = "this is window!!";
			obj.method.apply(void 0, ["apply", "B"]);
			// 実行結果：this is window!!, apply, B

			// thisありの状態でコンテキストを指定しない場合もやっぱりグローバル
			var b = {
				value : "this is b!",
				exec : function(){
					console.log(this.value);
					obj.method.apply(null, ["apply", "B"]);
				}
			}
			b.exec();
			// 実行結果：this is b!
			// 実行結果：this is window!!, apply, B

		div.
			関数はapply, callというメソッドを持っています。
			第一引数にコンテキストを渡すことで、実行コンテキストを動的に決定できます。

		div.
			apply, callのどっちを使うかという問題については「状況によって使いやすい方」を選ぶべきです。
		div.
			引数がすでに配列としてまとまっている場合はapply、列挙するならcall。
			callを使わずに配列にしてapplyで統一するというのもアリだと思います。

	section
		h1 実行時コンテキストのバインド
		div.
			実行時のコンテキストを予め固定しておくことも可能です。
			つまり、関数呼び出し/メソッド呼び出しにかかわらず、thisを固定できます。

		script(title="コンテキストのバインド",type="code/Javascript").

			var bind = function(func, context) {
				// contextを固定した関数を返す
				return function() {
					func.apply(context, arguments);
				}
			};

			// 固定する関数
			var func1 = function() {
				if(this === window) {
					console.log('this is window');
				} else {
					console.log(this.name);
				}
			}

			// bindするコンテキスト
			var contextObj = {
				name: 'this is contextObj'
			}

			// バインドせずに実行
			func1(); // -> this is window

			// contextとfunc1をバインドして実行
			var bindedFunc1 = bind(func1, contextObj);
			bindedFunc1(); // -> this is contextObj

			// もう新しいコンテキストは受け付けない
			bindedFunc1.apply({name:'new context'});　// -> this is contextObj

		div.
			bindedFunc1の方は、本来なら関数呼び出しなのでthisはwindowを指すはずです。
			先にコンテキストを固定したのでthisがちゃんとcontextオブジェクトを見るようになっています。
		div 理解してしまえば簡単ですね。

	script.
			function showThis(arg1, arg2) {
				// thisが何者なのかを表示
				var msg = "this is '" + (this.name || this.constructor && this.constructor.name);
				// 引数を表示する
				msg += "': " + arg1 + ", " + arg2;
				console.log(msg);
			}

			// 実行時コンテキストと
			var dummy = {
				name: 'DUMMY',
			};

// ライター情報
block writer
	include ../../persons/TomoYoshida